<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Qt在VS2022的使用</title>
      <link href="/2023/06/10/%E5%8D%9A%E5%AE%A2/Qt/Qt%E5%9C%A8VS2022%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/06/10/%E5%8D%9A%E5%AE%A2/Qt/Qt%E5%9C%A8VS2022%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Qt在VS2022的使用"><a href="#Qt在VS2022的使用" class="headerlink" title="Qt在VS2022的使用"></a>Qt在VS2022的使用</h1><h2 id="在VS2022里构建Qt开发环境"><a href="#在VS2022里构建Qt开发环境" class="headerlink" title="在VS2022里构建Qt开发环境"></a>在VS2022里构建Qt开发环境</h2><p>&emsp;&emsp;1. 前往Qt官网下载Qt,并且选择msvc版本<br><img src="https://cdn.jsdelivr.net/gh/YH2021-cc/imageResource/imgSnipaste_2023-06-10_16-55-01.png" alt=""><br>&emsp;&emsp;2. 前往微软官网下载VS2022社区版<br><img src="https://cdn.jsdelivr.net/gh/YH2021-cc/imageResource/imgSnipaste_2023-06-10_16-49-53.png" alt=""><br>&emsp;&emsp;3. 在VS2022上下载QT VS Tools插件<br><img src="https://cdn.jsdelivr.net/gh/YH2021-cc/imageResource/imgSnipaste_2023-06-10_16-50-33.png" alt=""><br>&emsp;&emsp;4. 选择QT VS Tools插件的Qt Versions功能添加Qt路径<br><img src="https://cdn.jsdelivr.net/gh/YH2021-cc/imageResource/imgSnipaste_2023-06-10_16-51-40.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/YH2021-cc/imageResource/imgSnipaste_2023-06-10_16-52-01.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/YH2021-cc/imageResource/imgSnipaste_2023-06-10_16-52-30.png" alt=""><br>&emsp;&emsp;5. 创建Qt项目<br><img src="https://cdn.jsdelivr.net/gh/YH2021-cc/imageResource/imgSnipaste_2023-06-10_16-53-07.png" alt=""></p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><div class='checkbox cyan'><input type="radio" />            <p>在ui界面选择控件右键没有转到槽</p>            </div><p>&emsp;&emsp;直接手动添加槽函数和connect函数,还有其他方法但是我觉得反而更慢,目前VS2022还不支持右键转到槽<br><div class='checkbox cyan'><input type="radio" />            <p>创建子窗体ui</p>            </div><br>&emsp;&emsp;当你创建了一个主窗口后再创建子窗体就需要手动连接ui文件和.h/.cpp文件</p><ol><li><p>创建子窗体ui<br><img src="https://cdn.jsdelivr.net/gh/YH2021-cc/imageResource/imgSnipaste_2023-06-10_17-12-42.png" alt=""></p></li><li><p>创建子窗体类,这个类必须继承QObject或其子类,孙子类等<br><img src="https://cdn.jsdelivr.net/gh/YH2021-cc/imageResource/imgSnipaste_2023-06-10_17-15-09.png" alt=""></p></li><li>在.h文件添加ui头文件和宏—使用#include”…”,VS会自动提示<br><img src="https://cdn.jsdelivr.net/gh/YH2021-cc/imageResource/imgSnipaste_2023-06-10_17-19-57.png" alt=""></li><li>绑定ui文件和子窗体类<br><img src="https://cdn.jsdelivr.net/gh/YH2021-cc/imageResource/imgSnipaste_2023-06-10_17-25-00.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/YH2021-cc/imageResource/imgSnipaste_2023-06-10_17-25-42.png" alt=""></li></ol><div class='checkbox cyan'><input type="radio" />            <p>使用QMessageBox中文乱码</p>            </div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">QMessageBox::information(this, &quot;提示&quot;, &quot;注册成功！&quot;);</span><br><span class="line">改成</span><br><span class="line">QMessageBox::information(this, QString::fromLocal8Bit(&quot;提示&quot;), QString::fromLocal8Bit(&quot;注册成功！&quot;));</span><br><span class="line"></span><br><span class="line">也可以在头文件加上#pragma execution_character_set(&quot;UTF-8&quot;)(建议使用)</span><br><span class="line"></span><br><span class="line">如果设置了上述仍然乱码,则是当前文本编码问题(在vs里会提示xx文件出现字符问题)</span><br><span class="line">    解决步骤</span><br><span class="line">            1. 将当前文件以编码保存另存为同名文件</span><br><span class="line">            2. 会提示是否替换当前文件选择是</span><br><span class="line">            3. 会让你选择编码格式,拉倒最上面选择Uniconde-8带签名的那个</span><br><span class="line">            4. 保存重新编译问题解决</span><br></pre></td></tr></table></figure><div class='checkbox cyan'><input type="radio" />            <p>子窗体退出直接退出程序</p>            </div><p>&emsp;&emsp;当主窗体被隐藏显示子窗体时应该使用exec()而不是show(),这样在关闭子窗体时后才显示主窗体,否则主子窗体会同时显示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">this-&gt;hide();//隐藏登录窗口</span><br><span class="line">RegisterWidget* registerWidget = new RegisterWidget();//创建子窗体</span><br><span class="line">registerWidget-&gt;exec();//显示注册窗口并阻塞到注册窗口关闭</span><br><span class="line">this-&gt;show();//显示登录窗口</span><br></pre></td></tr></table></figure><div class="tip warning"><p>VS创建Qt多窗口显示重复定义</p></div><p><img src="https://cdn.jsdelivr.net/gh/YH2021-cc/imageResource/imgSnipaste_2023-06-11_21-40-15.png" alt=""></p><div class='checkbox cyan'><input type="radio" />            <p>解决方法</p>            </div><p><img src="https://cdn.jsdelivr.net/gh/YH2021-cc/imageResource/imgSnipaste_2023-06-11_21-31-17.png" alt=""></p><div class='checkbox cyan'><input type="radio" />            <p>使用VS创建Qt窗体步骤</p>            </div><ol><li>创建窗体ui<br><img src="https://cdn.jsdelivr.net/gh/YH2021-cc/imageResource/imgSnipaste_2023-06-11_21-49-25.png" alt=""></li><li>重命名窗体ui并点击进入编辑<br><img src="https://cdn.jsdelivr.net/gh/YH2021-cc/imageResource/imgSnipaste_2023-06-11_21-51-03.png" alt=""></li><li>修改objectName<br><img src="https://cdn.jsdelivr.net/gh/YH2021-cc/imageResource/imgSnipaste_2023-06-11_21-53-14.png" alt=""></li><li>创建使用窗体ui的类并修改名字<br><img src="https://cdn.jsdelivr.net/gh/YH2021-cc/imageResource/imgSnipaste_2023-06-11_21-56-22.png" alt=""></li><li>在类的.h文件添加ui头文件和成员<br><img src="https://cdn.jsdelivr.net/gh/YH2021-cc/imageResource/imgSnipaste_2023-06-11_22-00-50.png" alt=""></li><li>在类的.cpp文件绑定类和ui<br><img src="https://cdn.jsdelivr.net/gh/YH2021-cc/imageResource/imgSnipaste_2023-06-11_22-02-33.png" alt=""></li></ol><div class='checkbox cyan'><input type="radio" />            <p>打开窗体焦点显示在密码框内</p>            </div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">窗体上有账号和密码文本框,但是每次打开时焦点总是锁定在密码框而不是账号框</span><br><span class="line">解决办法:将账号文本框设置为焦点,这样每次打开焦点会在账号文本框</span><br><span class="line">ui.accountEdit-&gt;setFocus();</span><br><span class="line">再添加下面语句就可以按tab键转移焦点到界面上的其他控件</span><br><span class="line">QWidget::setTabOrder(ui.accountEdit, ui.passwdEdit_3);</span><br></pre></td></tr></table></figure><div class='checkbox cyan'><input type="radio" />            <p>QSpinBox的信号使用问题</p>            </div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">只能这样用</span><br><span class="line">int* timeD = new int(0);</span><br><span class="line">QSpinBox* b1 = new QSpinBox();//创建输入整数控件,用来控制时间段的选取</span><br><span class="line">connect(b1, QOverload&lt;int&gt;::of(&amp;QSpinBox::valueChanged), this, [=](int value) &#123;*timeD = value; &#125;);</span><br><span class="line">不能这样用</span><br><span class="line">int* timeD = new int(0);</span><br><span class="line">QSpinBox* b1 = new QSpinBox();//创建输入整数控件,用来控制时间段的选取</span><br><span class="line">connect(b1, &amp;QSpinBox::valueChanged, this, [=](int value) &#123;*timeD = value; &#125;);</span><br></pre></td></tr></table></figure><div class='checkbox cyan'><input type="radio" />            <p>在lambda表达式里析构对象问题</p>            </div><p><img src="https://cdn.jsdelivr.net/gh/YH2021-cc/imageResource/imglambda.png" alt=""><br>&emsp;&emsp;在连接QCalendarWidget的clicked信号和lambda槽函数时，尝试访问了已被销毁的c1指针。当你在lambda表达式中使用变量时，需要注意变量的生命周期。在这种情况下，c1指针被释放（delete）并销毁（delete）之后，lambda表达式仍然持有对c1的引用。为了解决这个问题，你可以使用QObject::deleteLater()函数来延迟删除c1，以确保在lambda表达式执行完毕之后再进行删除。这样可以避免在槽函数中访问已被销毁的指针<br>&emsp;&emsp;</p><p><img src="https://cdn.jsdelivr.net/gh/YH2021-cc/imageResource/imglambda1.png" alt=""><br>&emsp;&emsp;c1-&gt;deleteLater()的作用是延迟删除c1指针所指向的对象。在Qt中，deleteLater()是QObject类的成员函数。当你调用deleteLater()时，它会将对象的删除操作推迟到事件循环的下一次迭代中。这意味着，直到当前事件处理完成并返回到事件循环时，对象才会被删除。这种延迟删除的机制对于在槽函数中使用对象非常有用，因为它确保在槽函数执行完毕后再进行对象的删除。在你的代码示例中，使用deleteLater()可以确保在clicked信号的槽函数执行完毕后再删除c1对象。这种方式可以避免在槽函数中访问已被销毁的对象，从而避免悬空指针的问题。<br><div class='checkbox cyan'><input type="radio" />            <p>未完待续…</p>            </div></p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> VS2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言结构体的内存对齐</title>
      <link href="/2023/06/08/%E5%8D%9A%E5%AE%A2/C%E8%AF%AD%E8%A8%80/%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"/>
      <url>/2023/06/08/%E5%8D%9A%E5%AE%A2/C%E8%AF%AD%E8%A8%80/%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</url>
      
        <content type="html"><![CDATA[<h1>C语言结构体的内存对齐</h1><div class="tip info"><p>什么是内存对齐</p></div><p>  内存对齐是指在计算机中，数据在内存中存储时，按照一定的规则对齐的过程。这个规则通常是根据数据类型的大小来确定的，以保证数据的访问效率和正确性<br> </p><div class="tip info"><p>为什么要内存对齐</p></div><p>  1. 硬件平台的限制</p><p>  有些硬件平台只支持读取特定类型的数据,如果不进行内存对齐就会出现错误</p><p>  2. 提高运行效率</p><p>  处理器对于对齐的内存只需要读取一次,对于未对齐的内存则需要读取至少2次<br> </p><div class="tip info"><p>对齐规则</p></div><p>  1. 第一个成员对齐在结构体变量偏移量为0的地址</p><p>  2. 其他成员对齐在对齐数的整数倍的地址</p><p>  3. 结构体的总大小为最大对齐数的整数倍</p><p>  4. 如果嵌套了结构体，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍<br> </p><div class="tip warning"><p>注意</p></div><p>  * 对齐数 = 该结构体成员变量自身的大小与编译器默认的一个对齐数的较小值,每个成员变量都有自己的对齐数</p><p>  * 最大对齐数 = 各个变量的对齐数中的最大值</p><p>  * VS中的默认对齐数为8<br> </p><div class="tip success"><p>计算结构体大小</p></div><p> 1. 计算每个成员变量的对齐数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct c</span><br><span class="line">&#123;                    成员变量大小       VS默认对齐数      对齐数</span><br><span class="line">    double db;           8                  8             8</span><br><span class="line">    int iy;              4                  8             4</span><br><span class="line">    char fg;             1                  8             1</span><br><span class="line">    double fd;           8                  8             8</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 2. 将他们对齐到内存地址</p><p><img src="https://cdn.jsdelivr.net/gh/YH2021-cc/imageResource/imgSnipaste_2023-06-08_11-21-37.png" alt=""></p><p> 3. 计算结构体大小</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">最大对齐数为8,因此最终结果一定是8的整数倍</span><br><span class="line"></span><br><span class="line">将每个变量的对齐数相加为21个字节不满足要求因此需要加上3个字节来达到内存对齐即为24个字节</span><br></pre></td></tr></table></figure><p> 4. 测试<br><img src="https://cdn.jsdelivr.net/gh/YH2021-cc/imageResource/imgSnipaste_2023-06-08_10-52-16.png" alt=""><br> </p><div class="tip sync"><p>修改默认对齐数</p></div><p>  要想修改默认对齐数需要借助预处理命令<span class='p blue'>#pragma pack(k)</span>,k是你要修改为的对齐数.如果不指定数字那么编译器就会将默认对齐数修改为原先默认值</p><div class='checkbox blue'><input type="radio" />            <p>修改前</p>            </div><p>  <img src="https://cdn.jsdelivr.net/gh/YH2021-cc/imageResource/imgSnipaste_2023-06-08_09-14-34.png" alt=""></p><div class='checkbox blue'><input type="radio" />            <p>修改后</p>            </div><p>  <img src="https://cdn.jsdelivr.net/gh/YH2021-cc/imageResource/imgSnipaste_2023-06-08_09-15-57.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 结构体 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言声明的分析</title>
      <link href="/2023/06/07/%E5%8D%9A%E5%AE%A2/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E5%A3%B0%E6%98%8E%E7%9A%84%E5%88%86%E6%9E%90/"/>
      <url>/2023/06/07/%E5%8D%9A%E5%AE%A2/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E5%A3%B0%E6%98%8E%E7%9A%84%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1>C语言声明的分析</h1><div class="note info simple"><p>前言</p></div><p>  学习完<span class='p red'>C语言</span>基础的同学应该对C语言的<span class='p blue'>声明</span>比较了解了,在学习的过程中我们所见到的声明一般较为简单,例如声明一个返回值为整型有两个参数的加法函数.它的原型就是int add(int x,int y); ,相信大家都知道该声明的含义,但如果是char <em>const</em>(*next)()这种声明你还能轻松解答吗?</p><div class="note info simple"><p>方法</p></div><p>  解析C语言声明的方法总共有6步,当你学会这个方法后相信你能解决许多复杂的声明了</p><div class="tip warning"><p>方法的步骤是有序的不能混乱</p></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">步骤如下:</span><br><span class="line">  <span class="number">1.</span>  先取最左边的标识符表示标识符是...</span><br><span class="line">  <span class="number">2.</span>  查看标识符右边的下一个符号若是方括号[表示是...的数组</span><br><span class="line">  <span class="number">3.</span>  如果是左括号(那么到右括号为止的内容表示为返回...的函数</span><br><span class="line">  <span class="number">4.</span>  如果左边的符号是一个左括号那么将左括号到右括号的部分作为一个整体然后从新从第<span class="number">2</span>步开始 </span><br><span class="line">  <span class="number">5.</span>  如果左边的符号是<span class="type">const</span> volatite *之一,就继续向左读直到符号不再是这三个之一然后重复第<span class="number">4</span>步</span><br><span class="line">           - <span class="type">const</span>: 表示为只读的...</span><br><span class="line">           - <span class="keyword">volatile</span>:  表示为易变的...</span><br><span class="line">           - *: 表示指向...的指针</span><br><span class="line">  <span class="number">6.</span>  剩下的基本都是普通数据类型直接读取即可</span><br></pre></td></tr></table></figure><div class="note info simple"><p>实例</p></div><p>  介绍完分析C语言声明的方法后我们来练习两个题</p><div class="note success simple"><p>练习一</p></div>.<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> * <span class="type">const</span> *(*next)()</span><br><span class="line"></span><br><span class="line">第一步: 先取最左边的标识符即next</span><br><span class="line"></span><br><span class="line">第二步: next右边的第一个符号不是[,执行第三步</span><br><span class="line"></span><br><span class="line">第三步: next右边的第一个符号也不是(,执行第四步</span><br><span class="line"></span><br><span class="line">第四步: next左边的第一个符号是*继续往左读是(停止读取,将(*next)()作为整体可知next是个函数指针</span><br><span class="line"></span><br><span class="line">第五步: 将(*next)()作为整体执行第四步,向左读第一个符号是*继续往左读,下一个符号是<span class="type">const</span>继续往左读,下一个符号是*继续往左读,下个符号是<span class="type">char</span>停止读取.此时我们得到了一个新整体 * <span class="type">const</span> *(*next)(),一步一步解析,*(*next)()表示next这个函数指针指向的函数的返回值是个指向...的指针,<span class="type">const</span> *(*next)()表示next这个函数指针指向的函数的返回值是个指向只读的...的指针,* <span class="type">const</span> *(*next)()则表示next这个函数指针指向的函数的返回值是个指向只读的指向...的指针的指针</span><br><span class="line"></span><br><span class="line">第六步: 将* <span class="type">const</span> *(*next)()作为一个整体,继续往左读,是<span class="type">char</span>,表示next这个函数指针指向的函数的返回值个是指向只读的指向<span class="type">char</span>的指针的指针</span><br><span class="line"></span><br><span class="line">总结: next是个函数指针,它指向一个返回一个指针的函数,该函数返回的指针指向一个只读的指向<span class="type">char</span>的指针</span><br></pre></td></tr></table></figure><div class="note success simple"><p>练习二</p></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> * (*c[<span class="number">10</span>])(<span class="type">int</span>** p)</span><br><span class="line"></span><br><span class="line">第一步: 先取最左边的标识符即c</span><br><span class="line"></span><br><span class="line">第二步: c右边的符号是[,那么c与[<span class="number">10</span>]结合,表示c是一个数组</span><br><span class="line"></span><br><span class="line">第三步: 将c[<span class="number">10</span>]作为整体,,继续往左读是个*表示c是一个拥有是个元素的指针数组,c的每个元素都是指向...的指针</span><br><span class="line"></span><br><span class="line">第四步: 将*c[<span class="number">10</span>]作为整体往左读是(,那么将(*c[<span class="number">10</span>])作为一个整体从第二步继续,往右读是(,那么(*c[<span class="number">10</span>])(<span class="type">int</span>** p)表示c这个指针数组的每个元素都是指向一个参数为<span class="type">int</span>**p的函数的指针</span><br><span class="line"></span><br><span class="line">第五步:将(*c[<span class="number">10</span>])(<span class="type">int</span>** p)作为整体继续往左读,是个*在往左读是<span class="type">char</span>停止读取,*(*c[<span class="number">10</span>])(<span class="type">int</span>** p)表示c这个指针数组的每个元素指向的函数返回的是一个指向...的指针    </span><br><span class="line"></span><br><span class="line">第六步: 将*(*c[<span class="number">10</span>])(<span class="type">int</span>** p)作为一个整体继续往左读,是<span class="type">char</span>,表示c这个指针数组的每个元素指向的函数返回的是一个指向<span class="type">char</span>的指针</span><br><span class="line"></span><br><span class="line">总结: c是个含有<span class="number">10</span>个元素的数组,每个元素都是指向一个函数的指针(函数指针),该函数带有一个<span class="type">int</span>**p的参数,返回的是指向<span class="type">char</span>的指针</span><br></pre></td></tr></table></figure><div class="tip info"><p>结语</p></div><p>  学习完本文以后相信你一定有所收获,现在就去网上或书上找一些比较复杂的C语言声明来巩固下学习成果吧!</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/06/05/hello-world/"/>
      <url>/2023/06/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><div class="note default simple"><p>哈哈滚滚滚</p></div><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
